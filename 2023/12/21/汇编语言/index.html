<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>汇编语言 | Sunning's Blog</title><meta name="author" content="Sunning"><meta name="copyright" content="Sunning"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="复习提纲第一章 绪论（无重点）第二章 访问寄存器和内存 mov指令的使用方式  内存中字的存储（地址的方向，比如一个16位，低字节存低地址，高字节存高地址。和堆栈操作放一起画一个堆栈情况，或者堆栈多少次操作之后数据存储的情况，每个单元的存储地址是多少。跟后面的跳转指令结合，是先push cs 还是先push ip（先push cs），内存状况是什么样子的）  堆栈操作（记住堆栈操作是什么样子的，s">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言">
<meta property="og:url" content="http://sunning03.githubl.io/2023/12/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="Sunning&#39;s Blog">
<meta property="og:description" content="复习提纲第一章 绪论（无重点）第二章 访问寄存器和内存 mov指令的使用方式  内存中字的存储（地址的方向，比如一个16位，低字节存低地址，高字节存高地址。和堆栈操作放一起画一个堆栈情况，或者堆栈多少次操作之后数据存储的情况，每个单元的存储地址是多少。跟后面的跳转指令结合，是先push cs 还是先push ip（先push cs），内存状况是什么样子的）  堆栈操作（记住堆栈操作是什么样子的，s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sunning03.githubl.io/img/profile.JPG">
<meta property="article:published_time" content="2023-12-21T04:49:00.000Z">
<meta property="article:modified_time" content="2023-12-21T04:49:16.371Z">
<meta property="article:author" content="Sunning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sunning03.githubl.io/img/profile.JPG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://sunning03.githubl.io/2023/12/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-21 12:49:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Sunning's Blog"><span class="site-name">Sunning's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-21T04:49:00.000Z" title="发表于 2023-12-21 12:49:00">2023-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-21T04:49:16.371Z" title="更新于 2023-12-21 12:49:16">2023-12-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="复习提纲"><a href="#复习提纲" class="headerlink" title="复习提纲"></a>复习提纲</h1><h2 id="第一章-绪论（无重点）"><a href="#第一章-绪论（无重点）" class="headerlink" title="第一章 绪论（无重点）"></a>第一章 绪论（无重点）</h2><h2 id="第二章-访问寄存器和内存"><a href="#第二章-访问寄存器和内存" class="headerlink" title="第二章 访问寄存器和内存"></a>第二章 访问寄存器和内存</h2><ol>
<li><p>mov指令的使用方式</p>
</li>
<li><p><strong>内存中字的存储</strong>（地址的方向，比如一个16位，低字节存低地址，高字节存高地址。和堆栈操作放一起画一个堆栈情况，或者堆栈多少次操作之后数据存储的情况，每个单元的存储地址是多少。跟后面的跳转指令结合，是先push cs 还是先push ip（先push cs），内存状况是什么样子的）</p>
</li>
<li><p>堆栈操作（记住堆栈操作是什么样子的，sp-2，方向是什么样子的，栈顶指针怎么指向的，如果没有元素的话指向哪里）</p>
</li>
</ol>
<h2 id="第三章-汇编语言源程序"><a href="#第三章-汇编语言源程序" class="headerlink" title="第三章 汇编语言源程序"></a>第三章 汇编语言源程序</h2><ol>
<li><p>汇编语言-可执行程序的编译流程（用什么东西编译它，怎样生成.exe文件）</p>
</li>
<li><p>loop指令的使用方式：loop指令包含的含义，怎样跳转，跟有条件跳转一样，发生一个短转移，具体是多少</p>
</li>
<li><p><strong>数据段、代码段、堆栈段的初始化方法</strong>：三个段怎么初始化，用什么方法，关系到能不能看懂最后的补全题和分析题，会从各个层面反复考察。画一个dw,dd，问数据空间到底多长，给一段代码，问它的跳转地址是多少，数据段、代码端和地址到底是怎么算的</p>
</li>
</ol>
<h2 id="第四章-内存寻址方式"><a href="#第四章-内存寻址方式" class="headerlink" title="第四章 内存寻址方式"></a><strong>第四章 内存寻址方式</strong></h2><p>基本都重要，访问内存的五种寻址方式：直接寻址、寄存器间接寻址（地址放在寄存器里面，用寄存器存储的地址去访问内存），寄存器相对寻址，基址变址寻址，基址变址相对寻址。掌握内存分段管理到底怎么管理：物理地址如何由段地址和偏移内存构成的。</p>
<h2 id="第五章-流程转移与子程序"><a href="#第五章-流程转移与子程序" class="headerlink" title="第五章 流程转移与子程序"></a>第五章 流程转移与子程序</h2><ol>
<li><p>无条件跳转指令和有条件跳转指令：原理，范围是多少，一个是8位补码，一个是16位补码。</p>
</li>
<li><p>函数调用与返回：考察原理，记住call 指令（push cs, push ip）return指令。会放在一个程序里面，要知道修改堆栈后是什么样子的，能够画出来。</p>
</li>
<li><p><strong>标志位寄存器</strong>：各个标志位是每一位是用来表示什么的。会考一些基础的，比如按位与和或会影响它的of等；做一次加法，问加一次加法后标志位是多少，问串指令和什么标志位相关</p>
</li>
</ol>
<h2 id="第六章-汇编语言源程序"><a href="#第六章-汇编语言源程序" class="headerlink" title="第六章 汇编语言源程序"></a>第六章 汇编语言源程序</h2><ol>
<li><p><strong>中断过程及中断向量表</strong>：中断过程和它产生的原理、中断向量表里面到底怎么找地址，</p>
</li>
<li><p>int指令与iret指令使用方法：记一下相关涉及到的操作</p>
</li>
<li><p>外设交互方法（主要是键盘）：键盘，复习跟键盘相关的东西。</p>
</li>
</ol>
<h1 id="知识点整理"><a href="#知识点整理" class="headerlink" title="知识点整理"></a>知识点整理</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ol>
<li>CPU是通过地址总线来指定存储单元的；CPU通过控制总线对外部器件进行控制；CPU与内存或其它器件之间的数据传送是通过数据总线来进行的</li>
</ol>
<h2 id="第二章-访问寄存器和内存-1"><a href="#第二章-访问寄存器和内存-1" class="headerlink" title="第二章 访问寄存器和内存"></a>第二章 访问寄存器和内存</h2><h3 id="2-1-寄存器及数据存储"><a href="#2-1-寄存器及数据存储" class="headerlink" title="2.1 寄存器及数据存储"></a>2.1 寄存器及数据存储</h3><ol>
<li><p>8086CPU有14个寄存器：<br>通用寄存器：AX、BX、CX、DX ;<br>变址寄存器：SI、DI ;<br>指针寄存器：SP、BP ;<br>指令指针寄存器： IP ;<br>段寄存器：CS、SS、DS、ES ; CS - 代码段寄存器DS - 数据段寄存器<br>SS - 栈段寄存器     ES - 附加段寄存器<br>标志寄存器：PSW<br>共性 ：8086CPU所有的寄存器都是16位的， 可以存放两个字节。一个字(word)可以存在一个16位寄存器中；这个字的高位字节存在这个寄存器的高8位寄存器；这个字的低位字节存在这个寄存器的低8位寄存器</p>
</li>
<li><p>一个16位寄存器存储一个16位的数据，最大值：2^16^-1</p>
</li>
<li><p>问题：8086上一代CPU中的寄存器都是8位的，如何保证程序的兼容性？</p>
<p>方案 ：通用寄存器均可以分为两个独立的8位寄存器使用</p>
</li>
</ol>
<h3 id="2-2-mov与add指令"><a href="#2-2-mov与add指令" class="headerlink" title="2.2 mov与add指令"></a>2.2 mov与add指令</h3><ol>
<li>一般数据传送指令 MOV<br>格式：MOV  dest，src；操作：src；例：MOV  AL，BL</li>
<li>ADD指令格式<br>格式：<br>ADD  OPRD1，OPRD2<br>操作：OPRD1+OPRD2<br>ADD指令的执行对状态标志位有影响<br><img src="D:\sunning_blog\source_posts\汇编语言\image-20231219183719774.png" alt="image-20231219183719774"></li>
</ol>
<h3 id="2-3-确定物理地址的方法"><a href="#2-3-确定物理地址的方法" class="headerlink" title="2.3 确定物理地址的方法"></a>2.3 确定物理地址的方法</h3><ol>
<li>CPU访问内存单元时要给出内存单元的地址。<br>所有的内存单元构成的存储空间是一个一维的线性空间。<br>每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。</li>
<li>8086有20位地址总线，可传送20位地址，寻址能力为1M。<br>8086是16位结构的CPU<br>8086CPU的解决方法<br>用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。<br>地址加法器合成物理地址的方法<br>物理地址&#x3D;段地址×16+偏移地址</li>
</ol>
<p><img src="D:\sunning_blog\source_posts\汇编语言\image-20231219185936523.png" alt="image-20231219185936523"></p>
<h3 id="2-4-内存的分段表示法"><a href="#2-4-内存的分段表示法" class="headerlink" title="2.4 内存的分段表示法"></a>2.4 内存的分段表示法</h3><ol>
<li>8086CPU用“（段地址×16）+偏移地址&#x3D;物理地址”的方式给出内存单元的物理地址。内存并没有分段，段的划分来自于CPU</li>
<li>段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。</li>
<li>偏移地址16位，变化范围为0<del>FFFFH，用偏移地址最多寻址64KB。<br>例：给定段地址2000H，用偏移地址寻址的范围是：20000H</del>2FFFFH，共64K</li>
</ol>
<h3 id="2-5-Debug的使用"><a href="#2-5-Debug的使用" class="headerlink" title="2.5 Debug的使用"></a>2.5 Debug的使用</h3><ol>
<li>用R命令查看、改变CPU寄存器的内容<br>用D命令查看内存中的内容<br>用E命令改变内存中的内容<br>用U命令将内存中的机器指令翻译成汇编指令<br>用A命令以汇编指令的格式在内存中写入机器指令<br>用T命令执行机器指令</li>
</ol>
<h3 id="2-6-CS、IP与代码段"><a href="#2-6-CS、IP与代码段" class="headerlink" title="2.6 CS、IP与代码段"></a>2.6 CS、IP与代码段</h3><ol>
<li>CS：代码段寄存器<br>IP： 指令指针寄存器<br>CS:IP：CPU将内存中CS:IP 指向的内容当作指令执行。</li>
<li>8086PC工作过程的简要描述：<br>（1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；<br>（2）IP &#x3D; IP + 所读取指令的长度，从而指向下一条指令；<br>（3）执行指令。 转到步骤（1），重复这个过程。</li>
<li>问：内存中有数据 B8 23 01 BB 03 00 89 D8 01 D8，究竟用作一般数据，还是用作指令？答：CPU将CS:IP指向的内存单元中的内容看作指令！</li>
</ol>
<h3 id="2-7-jump指令"><a href="#2-7-jump指令" class="headerlink" title="2.7 jump指令"></a>2.7 jump指令</h3><ol>
<li><p>同时修改CS、IP的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址：偏移地址</span><br><span class="line">jmp 2AE3:3</span><br><span class="line">jmp 3:0B16</span><br></pre></td></tr></table></figure>

<p>功能：用指令中给出的段地址修改CS，偏移地址修改IP。<br>仅修改IP的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp 某一合法寄存器</span><br><span class="line">jmp ax （类似于 mov IP, ax）</span><br><span class="line">jmp bx</span><br></pre></td></tr></table></figure>

<p>功能：用寄存器中的值修改IP。</p>
</li>
</ol>
<h3 id="2-8-内存中字的存储"><a href="#2-8-内存中字的存储" class="headerlink" title="2.8 内存中字的存储"></a>2.8 内存中字的存储</h3><ol>
<li>16位的字存储在一个16位的寄存器中，如何存储？<br>答：高8位放高字节，低8位放低字节<br>16位的字在内存中需要2个连续字节存储，怎么存放？<br>答：低位字节存在低地址单元，高位字节存在高地址单元<br>例：20000D（4E20H）存放0、1两个单元，18D（0012H）存放在2、3两个单元</li>
</ol>
<h3 id="2-9-用DS和-address-实现字的传送"><a href="#2-9-用DS和-address-实现字的传送" class="headerlink" title="2.9 用DS和[address]实现字的传送"></a>2.9 用DS和[address]实现字的传送</h3><ol>
<li>要求<br>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；<br>原理<br>在8086PC中，内存地址由段地址和偏移地址组成（段地址:偏移地址）<br>解决方案：DS和[address]配合<br>用 DS寄存器存放要访问的数据的段地址<br>偏移地址用[…]形式直接给出</li>
<li>8086不支持将数据直接送入段寄存器（设计问题）<br>解决办法：数据-一般寄存器-段寄存器</li>
</ol>
<h3 id="2-10-DS与数据段"><a href="#2-10-DS与数据段" class="headerlink" title="2.10 DS与数据段"></a>2.10 DS与数据段</h3><ol>
<li><table>
<thead>
<tr>
<th><strong>指令格式</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>mov 寄存器，数据</td>
<td>mov ax,8</td>
</tr>
<tr>
<td>mov 寄存器，寄存器</td>
<td>mov ax,bx</td>
</tr>
<tr>
<td>mov 寄存器，内存单元</td>
<td>mov ax,[0]</td>
</tr>
<tr>
<td>mov 内存单元，寄存器</td>
<td>mov [0],ax</td>
</tr>
<tr>
<td>mov 段寄存器，寄存器</td>
<td>mov ds,ax</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>指令格式</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>add 寄存器，数据</td>
<td>add ax,8</td>
</tr>
<tr>
<td>add 寄存器，寄存器</td>
<td>add ax,bx</td>
</tr>
<tr>
<td>add 寄存器，内存单元</td>
<td>add ax,[0]</td>
</tr>
<tr>
<td>add 内存单元，寄存器</td>
<td>add [0],ax</td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>指令格式</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>sub 寄存器，数据</td>
<td>sub ax,8</td>
</tr>
<tr>
<td>sub 寄存器，寄存器</td>
<td>sub ax,bx</td>
</tr>
<tr>
<td>sub 寄存器，内存单元</td>
<td>sub ax,[0]</td>
</tr>
<tr>
<td>sub 内存单元，寄存器</td>
<td>sub [0],ax</td>
</tr>
</tbody></table>
</li>
<li><p>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 11316</span><br><span class="line">mov [0], ax</span><br><span class="line">mov bx, [0]</span><br><span class="line">sub bx, [2]</span><br><span class="line">mov [2], bx</span><br></pre></td></tr></table></figure>

<p>（1）字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。<br>（2）用 mov 指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。<br>（3）[address]表示一个偏移地址为address的内存单元。<br>（4）在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。<br>（5）mov、add、sub是具有两个操作对象的指令，访问内存中的数据段（对照：jmp是具有一个操作对象的指令，对应内存中的代码段）。</p>
</li>
</ol>
<h3 id="2-11-栈与栈操作的实现"><a href="#2-11-栈与栈操作的实现" class="headerlink" title="2.11 栈与栈操作的实现"></a>2.11 栈与栈操作的实现</h3><ol>
<li><p>字型数据用两个单元存放，高地址单元放高 8 位，低地址单元放低8 位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CPU如何知道一段内存空间被当作栈使用？<br>执行push和pop的时候，如何知道哪个单元是栈顶单元？<br>结论：任意时刻，SS:SP指向栈顶元素。</p>
</li>
<li><p>寄存器CS和IP中存放着当前指令的段地址和偏移地址。<br>8086CPU中，有两个寄存器：<br>   段寄存器SS  　存放栈顶的段地址<br>   寄存器SP     　 存放栈顶的偏移地址</p>
</li>
<li><p>push ax<br>（1）SP&#x3D;SP–2；<br>（2）将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。<img src="D:\sunning_blog\source_posts\汇编语言\image-20231220125254002.png" alt="image-20231220125254002"></p>
</li>
<li><p>问题：如果我们将10000H~1000FH 这段空间当作栈，初始状态栈是空的，此时，SS&#x3D;1000H，SP&#x3D;？<br>SP &#x3D; 0010H<br><img src="D:\sunning_blog\source_posts\汇编语言\image-20231220125915528.png" alt="image-20231220125915528"></p>
</li>
<li><p>pop ax<br>（1）将SS:SP指向的内存单元处的数据送入ax中；<br>（2）SP &#x3D; SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。<img src="D:\sunning_blog\source_posts\汇编语言\image-20231220130057776.png" alt="image-20231220130057776"></p>
</li>
<li><p>push和pop指令是可以在寄存器和内存之间传送数据的。<br>push和pop指令的格式（1）<br>push 寄存器：将一个寄存器中的数据入栈<br>pop寄存器：出栈，用一个寄存器接收出栈的数据</p>
<p>例如：push ax；pop bx<br>push和pop指令的格式（2）<br>push 段寄存器：将一个段寄存器中的数据入栈<br>pop段寄存器：出栈，用一个段寄存器接收出栈的数据</p>
<p>例如：push ds；pop es<br>push和pop指令的格式（3）<br>push内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）<br>pop 内存单元：出栈，用一个内存字单元接收出栈的数据<br>例如：push [0]；pop [2]<br>指令执行时 ，CPU 要知道内存单元的地址，可以在 push、pop 指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中取得。</p>
</li>
<li><p>编程：将10000H~1000FH 这段空间当作栈，初始状态是空的，将 AX、BX、DS中的数据入栈。<img src="D:\sunning_blog\source_posts\汇编语言\image-20231220130511185.png" alt="image-20231220130511185"></p>
</li>
</ol>
<h3 id="2-12-关于段的总结"><a href="#2-12-关于段的总结" class="headerlink" title="2.12 关于段的总结"></a>2.12 关于段的总结</h3><ol>
<li>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。<br>我们可以用一个段存放数据，将它定义为“数据段”；<br>我们可以用一个段存放代码，将它定义为“代码段”；<br>我们可以用一个段当作栈，将它定义为“栈段”；</li>
<li>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：<br>对于数据段，将它的段地址放在 DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据段来访问；<br>对于代码段，将它的段地址放在 CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；<br>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP 中，这样CPU在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。</li>
</ol>
<h2 id="第三章-汇编语言源程序-1"><a href="#第三章-汇编语言源程序-1" class="headerlink" title="第三章 汇编语言源程序"></a>第三章 汇编语言源程序</h2><h3 id="3-1-用汇编语言写的源程序"><a href="#3-1-用汇编语言写的源程序" class="headerlink" title="3.1 用汇编语言写的源程序"></a>3.1 用汇编语言写的源程序</h3><ol>
<li><p>一个汇编语言程序从写出到最终执行的简要过程：编写-编译-连接-执行</p>
<p>编写：使用文本编辑器（如记事本等），用汇编语言编写汇编源程序。<br>编译链接：使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。<br>可执行文件中包含两部分内容：<br>程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）；相关的描述信息（比如：程序有多大、要占多少内存空间等）在操作系统中，执行可执行文件中的程序。<br>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。</p>
</li>
</ol>
<h3 id="3-2-由源程序到程序的运行"><a href="#3-2-由源程序到程序的运行" class="headerlink" title="3.2 由源程序到程序的运行"></a>3.2 由源程序到程序的运行</h3><ol>
<li><p>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p>
<p>没有对应的机器码的指令，最终不被CPU所执行。<img src="D:\sunning_blog\source_posts\汇编语言\image-20231221104324563.png" alt="image-20231221104324563"></p>
</li>
<li><p>segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。<br> segment和ends的功能是定义一个段，segment说明一个段开始，ends 说明一个段结束。<br>一个段必须有一个名称来标识，使用格式为：<br>段名 segment<br>段名 ends</p>
</li>
<li><p>注意：不要搞混了end和ends。<br>End 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。<br>如果程序写完了，要在结尾处加上伪指令end 。否则，编译器在编译程序时，无法知道程序在何处结束。</p>
</li>
<li><p>assume：含义为“假设”。<br>它假设某一段寄存器和程序中的某一个用 segment … ends 定义的段相关联。通过assume说明这种关联，在需要的情况下 ，编译程序可以将段寄存器和某一个具体的段相联系。</p>
</li>
<li><p>标号：一个标号指代了一个地址。<br>codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
</li>
<li><p>源程序中的“程序”<br>汇编源程序：<br>伪指令    （编译器处理）<br>汇编指令（编译为机器码）<br>程序：源程序中最终由计算机执行、处理的指令或数据。<img src="D:\sunning_blog\source_posts\汇编语言\image-20231221104822533.png" alt="image-20231221104822533"></p>
</li>
<li><p>可执行文件到底是怎么运行的？<br>DOS是一个单任务操作系统。<br>一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行。<br>而当P2运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P1，此后，P1继续运行。</p>
</li>
<li><p>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。<br>应该在程序的末尾添加返回的程序段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>

<p>这两条指令所实现的功能就是程序返回。</p>
</li>
<li><p><img src="D:\sunning_blog\source_posts\汇编语言\image-20231221105055585.png" alt="image-20231221105055585"></p>
</li>
<li><p>MASM 中包含了 8086 汇编程序设计中要用到的几个必需的工具（masm.exe编译、link.exe 连接、Debug.exe 调试，edit.com 和edlin.com 是两个编辑程序。）</p>
</li>
<li><p>masm编译源程序：输入要编译的源文件文件名后，按 Enter键。<br>目标文件（*.obj）是我们对一个源程序进行编译要得到的最终结果。<br>编译程序默认要输出的目标文件名为1.obj，所以可以不必再另行指定文件名。</p>
</li>
<li><p>link连接源程序：</p>
</li>
<li><p>进入DOS方式，进入C:\masm目录，运行link.exe。<br>如果目标文件不是以obj为扩展名的话，就要输入它的全名。比如：p1.bin。<br>在输入目标文件名的时候，要注意指明它所在的路径。这里，我们要连接的文件是当前路径下1.obj，所以此处输入“1”。<br>之后可以指定可执行文件的名称（默认为1.exe）</p>
</li>
</ol>
<h3 id="3-3程序执行过程的跟踪"><a href="#3-3程序执行过程的跟踪" class="headerlink" title="3.3程序执行过程的跟踪"></a>3.3程序执行过程的跟踪</h3><ol>
<li><p>为了观察程序的运行过程 ，我们可以使用Debug。<br>Debug 可以将程序加载入内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU 的控制，这样，我们就可以使用Debug 的相关命令来单步执行程序 ，查看每条指令的执行结果。</p>
</li>
<li><p>用R命令看一下各个寄存器的设置情况：<img src="D:\sunning_blog\source_posts\汇编语言\image-20231221105958101.png" alt="image-20231221105958101"></p>
<p>可以看到，Debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。1.exe 中程序的机器码共有15个字节。</p>
</li>
<li><p><img src="D:\sunning_blog\source_posts\汇编语言\image-20231221110013526.png" alt="image-20231221110013526"></p>
<p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：ds:0；<br>这个内存区的前256 个字节中存放的是PSP，dos用来和程序进行通信。<br>从 256字节处向后的空间存放的是程序。所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为 0，则物理地址为SA×16+0。<br>因为PSP占256（100H）字节，所以程序的物理地址是：<br>   <strong>SA×16+0+256&#x3D; SA×16+16×16&#x3D;（SA+16）×16+0</strong><br>   可用段地址和偏移地址表示为：SA+10:0。</p>
</li>
<li><p>用U命令查看一下其他指令：<img src="D:\sunning_blog\source_posts\汇编语言\image-20231221110350048.png" alt="image-20231221110350048"></p>
</li>
<li><p>用T命令担不执行程序中的每一条指令，并观察每条指令的执行结果，到了 int 21，我们要用P命令执行：<img src="D:\sunning_blog\source_posts\汇编语言\image-20231221110448987.png" alt="image-20231221110448987"></p>
<p>注：<br>继续命令P(Proceed)： 类似T命令，逐条执行 指令、显示结果。但遇子程序、中断等时，直接执行，然后显示结果<br>从指定地址处开始运行程序， 直到遇到断点或者程序正常结束。</p>
</li>
<li><p>需要注意的是，在 DOS 中运行程序时，是command将程序加载入内存；<br>所以程序运行结束后返回到command中，而在这里是debug 将程序加载入内存，所以程序运行结束后要返回到Debug中。</p>
</li>
</ol>
<h3 id="3-4-…-和-…"><a href="#3-4-…-和-…" class="headerlink" title="3.4 […]和(…)"></a>3.4 […]和(…)</h3><ol>
<li><p>我们要完整地描述一个内存单元，需要两种信息：<br>（1）内存单元的地址；<br>（2）内存单元的长度（类型）。<br>我们用[0]表示一个内存单元时，0 表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出。</p>
</li>
<li><p>[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令<br>mov ax,[bx]</p>
</li>
<li><p>为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号 “() ”来表示一个寄存器或一个内存单元中的内容。<br>举例：<br>（1）ax中的内容为0010H，我们可以这样来描述：(ax)&#x3D;0010H；<br>（2）2000:1000 处的内容为0010H，我们可以这样来描述：(21000H)&#x3D;0010H；<br>（3）对于mov ax,[2]的功能，我们可以这样来描述：(ax)&#x3D;((ds)×16+2)；<br>（4）对于mov [2],ax 的功能，我们可以这样来描述：((ds)×16+2)&#x3D;(ax)； （5）对于 add ax,2 的功能，我们可以这样来描述：(ax)&#x3D;(ax)+2；<br>（6）对于add ax,bx的功能，我们可以这样来描述：(ax)&#x3D;(ax)+(bx)；<br>（7）对于push ax的功能，我们可以这样来描述：<br>     (sp) &#x3D; (sp)-2<br>   ((ss)×16＋(sp))&#x3D;(ax)<br>（8）对于pop ax 的功能，我们可以这样来描述：<br>    (ax)&#x3D;((ss)×16+(sp))       (sp)&#x3D;(sp)+2</p>
</li>
<li><p>我们在Debug 中写过类似的指令：mov ax,[0]，表示将 ds:0 处的数据送入ax中。指令中，在“[…]”里用一个常量0表示内存单元的偏移地址。以后，我们用idata表示常量。<br>比如：<br>mov ax,[idata]就代表mov ax,[1]、mov ax,[2]、mov ax,[3]等。<br>mov bx,idata就代表mov bx,1、mov bx,2、mov bx,3等。<br>mov ds,idata就代表mov ds,1、mov ds,2等，它们都是非法指令。 </p>
</li>
<li><p><img src="D:\sunning_blog\source_posts\汇编语言\image-20231221111436821.png" alt="image-20231221111436821"></p>
<p>（1）先看一下程序的前三条指令：</p>
<p>mov ax,2000H<br>mov ds,ax<br>mov bx,1000H</p>
<p>这三条指令执行后<br>  ds&#x3D;2000H，<br>  bx&#x3D;1000H；</p>
<p>（2）再看第4条指令：</p>
<p>mov ax,[bx]</p>
<p>指令执行前：<br>   ds&#x3D;2000H，bx&#x3D;1000H，则mov ax,[bx]将把内存2000:1000处的字型数据送入ax中。<br>该指令执行后:<br>   ax&#x3D;00beH。</p>
<p>（3）再看第5、6条指令：<br>inc bx<br>inc bx</p>
<p>指令执行前：<br>  bx&#x3D;1000H。<br>执行后:<br>  bx&#x3D;1002H。<br>（4）再看第7条指令：</p>
<p>mov [bx],ax<br> 指令执行前：<br>ds&#x3D;2000H，bx&#x3D;1002H，而<br>mov [bx],ax将把ax中的数据送入内存2000:1002处。<br>指令执行后:<br>2000:1002单元的内容为BE，2000:1003单元的内容为00。<br>（5）再看第8、9条指令：<br>inc bx<br>inc bx<br>指令执行前：<br>  bx&#x3D;1002H。<br>执行后：<br>   bx&#x3D;1004H。</p>
<p>（6）再看第10条指令：<br>　mov [bx],ax<br>   指令执行前：<br>  ds&#x3D;2000H，bx&#x3D;1004H，则<br>  mov [bx],ax将把ax中的数据<br>  送入内存2000:1004处。<br>指令执行后：<br>   2000:1004单元的内容为BE，2000:1005单元的内容为00。<br>（7）再看第11条指令：<br>inc bx<br>   指令执行前：<br>   bx&#x3D;1004H。 　　　　　　　　　　　<br>　执行后：<br>   bx&#x3D;1005H。<br>（8）再看第12条指令：<br>  mov [bx],al<br>  指令执行前：<br>ds&#x3D;2000H，bx&#x3D;1005H，则<br>mov [bx],ax将把al中的数据送<br>入内存2000:1005处。<br>   指令执行后：<br>2000:1005单元的内容为BE。<br>（9）接下来是第13条指令：<br>  inc bx<br>  指令执行前：<br>  bx&#x3D;1005H，<br>   指令执行后：<br>  bx&#x3D;1006H。<br>（10）再看第12条指令：<br> mov [bx],al<br>  指令执行前：<br>ds&#x3D;2000H，bx&#x3D;1006H，则<br>mov [bx],ax将把al中的数据<br>送入内存2000:1006处。<br>  指令执行后:<br>2000:1006单元的内容为BE。</p>
</li>
</ol>
<h3 id="3-5-loop指令简介"><a href="#3-5-loop指令简介" class="headerlink" title="3.5 loop指令简介"></a>3.5 loop指令简介</h3><ol>
<li><p>指令的格式是：loop 标号，CPU 执行loop指令的时候，要进行两步操作：<br>① (cx)&#x3D;(cx)-1；<br>② 判断<strong>cx</strong>中的值，不为零则转至标号处执行程序，如果为零则向下执行。<br><strong>注意：是要判断cx中的值</strong></p>
</li>
<li><p>任务1：编程计算2∧2，结果存放在ax中。<br>   分析：<br>   设(ax)&#x3D;2，可计算：(ax)&#x3D; (ax)×2，最后(ax)中为2∧2的值。N×2可用N+N 实现。</p>
<p>程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">	code segment</span><br><span class="line">		mov ax,2</span><br><span class="line">		add ax,ax</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">	code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>任务2：编程计算2∧3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">	code segment</span><br><span class="line">		mov ax,2</span><br><span class="line">		add ax,ax</span><br><span class="line">		add ax,ax</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">	code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>任务3：编程计算2∧12。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">	code segment</span><br><span class="line">		mov ax,2</span><br><span class="line">		;做11次add ax,ax</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">	code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>按照我们的算法，计算2∧^12^需要11条重复的指令add ax, ax。我们显然不希望这样来写程序，这里，可用loop来简化我们的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">	code segment</span><br><span class="line">		mov ax,2</span><br><span class="line">		mov cx,11</span><br><span class="line">	s:  add ax,ax</span><br><span class="line">		loop s</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">	code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>程序分析：<br>（1）标号在汇编语言中，标号代表一个地址，此程序中有一个标号s 。它实际上标识了一个地址，这个地址处有一条指令：add ax,ax。<br>（2）loop s<br>CPU 执行loop s的时候，要进行两步操作：<br>① (cx)&#x3D;(cx)-1；<br>② 判断cx 中的值，不为0 则转至标号s 所标识的地址处执行(这里的指令是“add ax,ax)，如果为零则执行下一条指令(下一条指令是mov ax,4c00h)。<br>（3）以下三条指令<br>       mov cx,11<br>   s: add ax,ax<br>      loop s<br>执行loop s时，首先要将(cx)减1，然后若(cx)不为0，则向前转至s处执行add ax,ax。所以，我们可以利用cx来控制add ax,ax的执行次数。</p>
</li>
<li><p>从上面的过程中，我们可以总结出用cx和loop 指令相配合实现循环功能的三个要点：<br>（1）在cx中存放循环次数；<br>（2）loop 指令中的标号所标识地址要在前面；<br>（3）要循环执行的程序段，要写在标号和loop 指令的中间。</p>
</li>
<li><p>用cx和loop指令相配合实现循环功能的程序框架如下：<br>mov cx,循环次数<br>s:     循环执行的程序段<br>loop s </p>
</li>
<li><p>问题<br>用加法计算123 x236 ，结果存在ax 中。<br>思考后看分析。</p>
</li>
<li><p>程序代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov cx,236</span><br><span class="line">	s:add ax,123</span><br><span class="line">	loop s</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-6-loop-指令使用"><a href="#3-6-loop-指令使用" class="headerlink" title="3.6 loop 指令使用"></a>3.6 loop 指令使用</h3><ol>
<li><p>考虑这样一个问题，计算ffff:0006单元中的数乘以3，结果存储在dx中。我们分析一下：<br>（1）运算后的结果是否会超出dx所能存储的范围？<br>   ffff:0006 单元中的数是一个字节型的数据，范围在0~255之间，则用它和3相乘结果不会大于65535，可以在dx 中存放下。<br>（2）我们用循环累加来实现乘法，用哪个寄存器进行累加？我们将ffff:0006单元中的数赋值给ax，用dx进行累加。先设(dx)&#x3D;0，然后做3次(dx)&#x3D;(dx)+(ax)。<br>（3） ffff:0006单元是一个字节单元，ax是一个 16 位寄存器，数据长度不一样，如何赋值？</p>
<p>那么我们如何赋值？<br>设ffff:0006单元中的数据是XXH，若要ax中的值和ffff:0006单元中的相等，ax中的数据应为00XXH。<br>   所以，若实现ffff:0006单元向ax 赋值，我们应该令(ah)&#x3D;0，(al)&#x3D;(ffff6H)。<br>实现计算ffff:0006单元中的数乘以3，结果存储在dx中的程序代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,6</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,3</span><br><span class="line">s:	add dx,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://sunning03.githubl.io">Sunning</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://sunning03.githubl.io/2023/12/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">http://sunning03.githubl.io/2023/12/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sunning03.githubl.io" target="_blank">Sunning's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/profile.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/12/17/%E6%B5%91%E9%87%91%E7%92%9E%E7%8E%89%EF%BC%8C%E6%B5%81%E6%B0%B4%E8%A1%8C%E4%BA%91/" title="浑金璞玉，流水行云"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">浑金璞玉，流水行云</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sunning</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sunning03"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/sunning03" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sunning@njfu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2"><span class="toc-number">1.</span> <span class="toc-text">复习提纲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA%EF%BC%88%E6%97%A0%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 绪论（无重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 访问寄存器和内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 汇编语言源程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 内存寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%B5%81%E7%A8%8B%E8%BD%AC%E7%A7%BB%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">第五章 流程转移与子程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">第六章 汇编语言源程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">知识点整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">2.1.</span> <span class="toc-text">第一章 绪论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98-1"><span class="toc-number">2.2.</span> <span class="toc-text">第二章 访问寄存器和内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 寄存器及数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-mov%E4%B8%8Eadd%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 mov与add指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A1%AE%E5%AE%9A%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 确定物理地址的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E6%AE%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 内存的分段表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Debug%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5 Debug的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-CS%E3%80%81IP%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6 CS、IP与代码段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-jump%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.7 jump指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.8.</span> <span class="toc-text">2.8 内存中字的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E7%94%A8DS%E5%92%8C-address-%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81"><span class="toc-number">2.2.9.</span> <span class="toc-text">2.9 用DS和[address]实现字的传送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-DS%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">2.2.10.</span> <span class="toc-text">2.10 DS与数据段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E6%A0%88%E4%B8%8E%E6%A0%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.11.</span> <span class="toc-text">2.11 栈与栈操作的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E5%85%B3%E4%BA%8E%E6%AE%B5%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.12.</span> <span class="toc-text">2.12 关于段的总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F-1"><span class="toc-number">2.3.</span> <span class="toc-text">第三章 汇编语言源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 用汇编语言写的源程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%94%B1%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 由源程序到程序的运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B7%9F%E8%B8%AA"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3程序执行过程的跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E2%80%A6-%E5%92%8C-%E2%80%A6"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 […]和(…)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-loop%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5 loop指令简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-loop-%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.6.</span> <span class="toc-text">3.6 loop 指令使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" title="汇编语言">汇编语言</a><time datetime="2023-12-21T04:49:00.000Z" title="发表于 2023-12-21 12:49:00">2023-12-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/17/%E6%B5%91%E9%87%91%E7%92%9E%E7%8E%89%EF%BC%8C%E6%B5%81%E6%B0%B4%E8%A1%8C%E4%BA%91/" title="浑金璞玉，流水行云">浑金璞玉，流水行云</a><time datetime="2023-12-17T15:54:15.000Z" title="发表于 2023-12-17 23:54:15">2023-12-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/15/%E6%88%91%E6%8A%A5%E8%B7%AF%E9%95%BF%E5%97%9F%E6%97%A5%E6%9A%AE/" title="我报路长嗟日暮">我报路长嗟日暮</a><time datetime="2023-12-15T08:46:06.000Z" title="发表于 2023-12-15 16:46:06">2023-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/15/%E5%AD%99%E5%AE%81%E7%9A%84%E5%8D%9A%E5%AE%A2/" title="孙宁的博客">孙宁的博客</a><time datetime="2023-12-15T08:45:24.000Z" title="发表于 2023-12-15 16:45:24">2023-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/15/%E5%BF%83%E7%81%B5%E7%9A%84%E5%BE%AE%E5%85%89/" title="心灵的微光">心灵的微光</a><time datetime="2023-12-15T08:41:29.000Z" title="发表于 2023-12-15 16:41:29">2023-12-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Sunning</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>